// Copyright (C) 2000, Luca Padovani <luca.padovani@cs.unibo.it>.
// 
// This file is part of GtkMathView, a Gtk widget for MathML.
// 
// GtkMathView is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
// 
// GtkMathView is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with GtkMathView; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
// 
// For details, see the GtkMathView World-Wide-Web page,
// http://cs.unibo.it/~lpadovan/mml-widget, or send a mail to
// <luca.padovani@cs.unibo.it>

#ifndef StringU_icc
#define StringU_icc

#include <stddef.h>
#include <string.h>

#include "unidefs.h"
#include "StringU.hh"

template <typename CharX>
StringU<CharX>::StringU() : String()
{
  Init();
}

template <typename CharX>
StringU<CharX>::StringU(unsigned len) : String()
{
  Init(len);
  for (unsigned i = 0; i < length; i++) data[i] = 0;
}

template <typename CharX>
StringU<CharX>::StringU(const char* s) : String()
{
  Init();  
  Set(s);
}

template <typename CharX>
StringU<CharX>::StringU(const Char8* s, unsigned n) : String()
{
  Init();
  Set(s, n);
}

template <typename CharX>
StringU<CharX>::StringU(const Char16* s, unsigned n) : String()
{
  Init();
  Set(s, n);
}

template <typename CharX>
StringU<CharX>::StringU(const Char32* s, unsigned n) : String()
{
  Init();
  Set(s, n);
}

template <typename CharX>
StringU<CharX>::StringU(const String& s) : String()
{
  Init();
  Set(s);
}

template <typename CharX>
StringU<CharX>::StringU(const String& s, unsigned o, unsigned n) : String()
{
  Init();
  Set(s, o, n);
}

template <typename CharX>
StringU<CharX>::~StringU()
{
  Delete();
}

template <typename CharX>
void StringU<CharX>::Init(unsigned len)
{
  if (len == 0) data = NULL;
  else data = new CharX[len];
  length = len;
}

template <typename CharX>
void StringU<CharX>::Delete()
{
  delete [] data;
}

template <typename CharX>
String* StringU<CharX>::Clone() const
{
  StringU<CharX>* cloned = new StringU<CharX>;
  cloned->Set(data, GetLength());

  return cloned;
}

template <typename CharX>
void StringU<CharX>::TrimSpacesLeft()
{
  unsigned length = GetLength();
  unsigned first_nb = 0;
  while (first_nb < length && isXmlSpace(GetChar(first_nb))) first_nb++;

  for (unsigned i = 0; i < length - first_nb; i++)
    SetChar(i, GetChar(first_nb + i));

  length -= first_nb;
  SetLength(length);
}

template <typename CharX>
void StringU<CharX>::TrimSpacesRight()
{
  unsigned length = GetLength();
  while (length > 0 && isXmlSpace(GetChar(length - 1))) length--;
  SetLength(length);
}

template <typename CharX>
void StringU<CharX>::CollapseSpaces()
{
  unsigned dest = 0;
  unsigned i = 0;
  while (i < GetLength()) {
    if (!isXmlSpace(GetChar(i))) {
      SetChar(dest, GetChar(i));
      dest++;
      i++;
    } else {
      SetChar(dest, ' ');
      dest++;
      while (i < GetLength() && isXmlSpace(GetChar(i))) i++;
    }
  }

  SetLength(dest);
}

template <typename CharX>
void StringU<CharX>::DeleteSpaces()
{
  unsigned dest = 0;
  unsigned i = 0;
  while (i < GetLength()) {
    if (!isXmlSpace(GetChar(i))) {
      SetChar(dest, GetChar(i));
      dest++;
    }
    i++;
  }

  SetLength(dest);
}

template <typename CharX>
void StringU<CharX>::Append(const String& s)
{
  unsigned newLength = GetLength() + s.GetLength();
  if (newLength == GetLength()) return;
  
  Char* newData = new Char[newLength + 1];
  assert(newData != 0);

  unsigned i;
  for (i = 0; i < GetLength(); i++) newData[i] = GetChar(i);
  for (i = 0; i < s.GetLength(); i++) newData[i + GetLength()] = s.GetChar(i);

  Set(newData, newLength);
  delete [] newData;
}

template <typename CharX>
void StringU<CharX>::Set(const String& s)
{
  Char big = s.GetBiggestChar();

  CharX x = static_cast<CharX>(big);
  assert(x == big);

  Delete();
  Init(s.GetLength());
  for (unsigned i = 0; i < length; i++) data[i] = s.GetChar(i);
}

template <typename CharX>
void StringU<CharX>::Set(const char* s)
{
  Set(s, strlen(s));
}

template <typename CharX>
void StringU<CharX>::Set(const Char8* s, unsigned n)
{
  assert(s != NULL || n == 0);

  Delete();
  Init(n);
  for (unsigned i = 0; i < length; i++) SetChar(i, s[i]);
}

template <typename CharX>
void StringU<CharX>::Set(const Char16* s, unsigned n)
{
  assert(s != NULL || n == 0);

  Delete();
  Init(n);
  for (unsigned i = 0; i < length; i++) SetChar(i, s[i]);
}

template <typename CharX>
void StringU<CharX>::Set(const Char32* s, unsigned n)
{
  assert(s != NULL || n == 0);

  Delete();
  Init(n);
  for (unsigned i = 0; i < length; i++) SetChar(i, s[i]);
}

template <typename CharX>
void StringU<CharX>::Set(const String& s, unsigned offset, unsigned length)
{
  assert(offset + length <= s.GetLength());

  Delete();
  Init(length);
  for (unsigned i = 0; i < length; i++) SetChar(i, s.GetChar(offset + i));
}

template <typename CharX>
void StringU<CharX>::SetChar(unsigned i, Char ch)
{
  assert(i < length);

  CharX x = static_cast<CharX>(ch);
  assert(x == ch);

  data[i] = ch;
}

template <typename CharX>
Char StringU<CharX>::GetChar(unsigned i) const
{
  assert(i < length);
  return static_cast<Char>(data[i]);
}

template <typename CharX>
unsigned StringU<CharX>::GetLength() const
{
  return length;
}

template <typename CharX>
void StringU<CharX>::SetLength(unsigned n)
{
  assert(n <= length);
  length = n;
}

#endif
