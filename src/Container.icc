// Copyright (C) 2000, Luca Padovani <luca.padovani@cs.unibo.it>.
// 
// This file is part of GtkMathView, a Gtk widget for MathML.
// 
// GtkMathView is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
// 
// GtkMathView is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with GtkMathView; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
// 
// For details, see the GtkMathView World-Wide-Web page,
// http://cs.unibo.it/~lpadovan/mml-widget, or send a mail to
// <luca.padovani@cs.unibo.it>

#ifndef Container_icc
#define Container_icc

template <class Type>
Container<Type>::Container()
{
  n = 0;
  first = last = 0;
}

template <class Type>
Container<Type>::Container(const Container<Type>& cont)
{
  n = 0;
  first = last = 0;
  for (Iterator<Type> i(cont); i.More(); i.Next()) AddLast(i());
}

template <class Type>
Container<Type>::~Container()
{
  while (!IsEmpty()) RemoveFirst();
}

template <class Type>
void Container<Type>::AddFirst(Type obj)
{
  Wrapper* w = new Wrapper;
  w->next = first;
  w->prev = 0;
  w->obj  = obj;

  if (first != 0) {
    first->prev = w;
    first = w;
  } else
    first = last = w;

  n++;
}

template <class Type>
void Container<Type>::AddLast(Type obj)
{
  Wrapper* w = new Wrapper;
  w->next = 0;
  w->prev = last;
  w->obj  = obj;

  if (last != 0) {
    last->next = w;
    last = w;
  } else
    first = last = w;

  n++;
}

template <class Type>
Type Container<Type>::RemoveFirst()
{
  assert(first != 0);

  Wrapper* w   = first;
  Type     obj = w->obj;

  first = first->next;
  if (first == 0) last = 0;
  else first->prev = 0;

  delete w;
  n--;

  return obj;
}

template <class Type>
Type Container<Type>::RemoveLast()
{
  assert(last != 0);

  Wrapper* w   = last;
  Type     obj = w->obj;

  last = last->prev;
  if (last == 0) first = 0;
  else last->next = 0;

  delete w;
  n--;

  return obj;
}

template <class Type>
void Container<Type>::Remove(Type obj)
{
  Wrapper* w = Search(obj);
  assert(w != 0);

  if (w->prev == 0) first = w->next;
  else w->prev->next = w->next;

  if (w->next == 0) last = w->prev;
  else w->next->prev = w->prev;

  delete w;
  n--;
}

template <class Type>
inline Type Container<Type>::GetFirst() const
{
  assert(first != 0);
  return first->obj;
}

template <class Type>
inline Type Container<Type>::GetLast() const
{
  assert(last != 0);
  return last->obj;
}

template <class Type>
inline void Container<Type>::Set(unsigned i, Type obj)
{
  assert(i < GetSize());

  Wrapper* w = Search(i);
  assert(w != 0);

  w->obj = obj;
}

template <class Type>
inline Type Container<Type>::Get(unsigned i) const
{
  assert(i < GetSize());

  Wrapper* w = first;
  while (i-- > 0) w = w->next;

  return w->obj;
}

template <class Type>
inline bool Container<Type>::Contains(Type obj) const
{
  Wrapper* w = Search(obj);
  return w != 0;
}

template <class Type>
inline void Container<Type>::Substitute(Type oldObj, Type newObj)
{
  Wrapper* w = Search(oldObj);
  if (w != 0) w->obj = newObj;
}

template <class Type>
inline int Container<Type>::IndexOf(Type obj) const
{
  int index = -1;
  Search(obj, &index);
  return index;
}

template <class Type>
Container<Type>::Wrapper* Container<Type>::Search(const Type obj, int* index) const
{
  int i = -1;
  Wrapper* w = first;

  while (w != 0 && w->obj != obj) {
    i++;
    w = w->next;
  }

  if (index != 0) {
    if (w != 0) *index = i;
    else *index = -1;
  }

  return w;
}

template <class Type>
Container<Type>::Wrapper* Container<Type>::Search(unsigned i) const
{	
  Wrapper* w = first;

  while (w != 0 && i > 0)
    {
      i--;
      w = w->next;
    }

  return w;
}

#endif // Container_icc
